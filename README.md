# Biquadris
The game of biquadris was developed by Netra Mali, Khubi Shah, and Pari Shah as part of coursework. This game is another version of Tetris where the player has infinite time to make the next move. We added a bonus feature to the game by making it multiplayer and single player.

# Built
The game was built in C++ using Vim and Visual Studio. 

# Demo
The game can be played in both command line interface and graphical user interface.
* The user can specify level from 1 to 4
* Choose a seed value to change the probability of the blocks being dropped
* Specify number of players
* Provide a file with a list of blocks that they want to play with

![...](/Text1.PNG)
![...](/Text2.PNG)
![...](/Graphical1.PNG)
![...](/Graphical2.PNG)

# Design Patterns
### Factory Design Pattern
The game uses the factory design pattern twice, once for the Level Class and once for the Block Class. 

For the Level class, the abstract base class Level had child classes Level0, Level1, Level2, Level3, and Level4, each of which had their own concrete implementation of a function called “generateBlock”. This was necessary because each level had its own method for generating a block based on either a file or a certain probability. Since each player had a level pointer variable that points to a child level depending on which level that the player is currently in, you simply call “level->generateBlock()” to generate the next blocks for that player. Due to dynamic dispatch, the appropriate generateBlock function will be called. 

For the Block Class, there was an abstract base class called Block, which had subclasses IBlock, TBlock, LBlock, JBlock, SBlock, ZBlock, StarBlock, etc. Each of the child classes had a concrete implementation of the pure virtual methods inside Block, which were printLine1() and printLine2(), which printed out the first and second line of the block shape, respectively, for the text version of the game. These functions were used as a part of outputting the next block on the game display for each player. Inside each child block’s constructor, the inherited vector of cells variable was also initialized differently based on the shape of the block, while the rest of the construction process remained the same. 

### Observer Pattern
The observer pattern was used in order to display text, display graphics, and keep track of how many blocks were fully cleared on the board. In order to do this, the graphics class and textDisplay classes were declared as children of the abstract base class Observer. Another observer child class was Block. All of these observers were attached to Cells, which inherited from the abstract base class Subject. In this way, whenever a cell’s shape was updated, the displays would be notified and update accordingly. The block that contains that particular cell piece was notified as well, since it needed to know how many of its member cells were cleared on the board, so that it can update its own vector of BlockCells. This was essential, as there needed to be a way to allocate points based on the clearing on an entire block. 

### MVC Pattern
The MVC pattern was implicitly applied in the game design. Classes textDisplay and graphicsDisplay served as the Views classes, as they were responsible for printing out the bulk of the game display (the board for every single player). Classes board, cell, coordinate, and block were all part of the Model aspect, as though the player did not directly change them, they used the Controller aspect (which was in Main, the Biquadris Class, and the Player Class) to take in commands from standard input. The Controller classes then simply called functions of the board based on the commands sent in, and manipulated blocks on the board with its own functions and fields. These changes in the Model aspect were then simply printed out or visually generated by the Views classes.



